import{g as t}from"./index-B1MHyEgd.js";function e(t,e){return e.forEach(function(e){e&&"string"!=typeof e&&!Array.isArray(e)&&Object.keys(e).forEach(function(o){if("default"!==o&&!(o in t)){var i=Object.getOwnPropertyDescriptor(e,o);Object.defineProperty(t,o,i.get?i:{enumerable:!0,get:function(){return e[o]}})}})}),Object.freeze(t)}var o,i={exports:{}};var r,s=o?i.exports:(o=1,r="undefined"==typeof window?i.exports:window,i.exports=((t,e)=>(()=>{var o={512:t=>{t.exports=e},944:e=>{e.exports=t}},i={};function r(t){var e=i[t];if(void 0!==e)return e.exports;var s=i[t]={exports:{}};return o[t](s,s.exports,r),s.exports}r.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return r.d(e,{a:e}),e},r.d=(t,e)=>{for(var o in e)r.o(e,o)&&!r.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:e[o]})},r.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e);var s={};r.d(s,{default:()=>E});var n=r(944),a=r.n(n),p=r(512),h=r.n(p);let{seriesTypes:{mapline:{prototype:{pointClass:l}}}}=h(),{pick:f,isString:d,isNumber:g}=a(),{series:{prototype:{pointClass:c}},seriesTypes:{column:m,map:u,mapline:y}}=h(),{addEvent:w,arrayMax:x,arrayMin:P,defined:b,extend:v,isArray:O,merge:L,pick:k,relativeLength:A}=a();class W extends y{static getLength(t,e){return Math.sqrt(t*t+e*e)}static normalize(t,e){let o=this.getLength(t,e);return[t/o,e/o]}static markerEndPath(t,e,o,i){let r=A(i.width||0,this.getLength(e[0]-t[0],e[1]-t[1])),s=i.markerType||"arrow",[n,a]=this.normalize(e[0]-t[0],e[1]-t[1]),p=[];if("arrow"===s){let[i,s]=t;i-=n*r,s-=a*r,p.push(["L",i,s]),p.push(["L",o[0],o[1]]),[i,s]=e,i+=n*r,s+=a*r,p.push(["L",i,s])}if("mushroom"===s){let[i,s]=t,[h,l]=e,[f,d]=o,g=(h-i)/2+i,c=(l-s)/2+s;i-=n*r,s-=a*r,p.push(["L",i,s]),h+=n*r,l+=a*r,p.push(["Q",2*(f-g)+g,2*(d-c)+c,h,l])}return p}animate(t){let e=this.points;t||e.forEach(t=>{if(t.shapeArgs&&O(t.shapeArgs.d)&&t.shapeArgs.d.length){let e=t.shapeArgs.d,o=e[0][1],i=e[0][2];if(o&&i){let r=[];for(let t=0;t<e.length;t++){r.push([...e[t]]);for(let s=1;s<e[t].length;s++)r[t][s]=s%2?o:i}t.graphic&&(t.graphic.attr({d:r}),t.graphic.animate({d:e}))}}})}getLinkWidth(t){let e=this.options.width,o=t.options.weight||this.options.weight;if(t.options.weight=o,e&&!o)return e;let i=this.smallestWeight,r=this.greatestWeight;if(!b(o)||!i||!r)return 0;let s=this.options.minWidth;return(o-i)*(this.options.maxWidth-s)/(r-i||1)+s}autoCurve(t,e,o,i,r,s){let n=o-t,a=i-e,p=(o-t)/2+t-r,h=(i-e)/2+e-s,l=n*p+a*h,f=Math.atan2(n*h-a*p,l),d=180*f/Math.PI;return d<0&&(d=360+d),-.7*Math.sin(f=d*Math.PI/180)}pointAttribs(t,e){let o=u.prototype.pointAttribs.call(this,t,e);return o.fill=k(t.options.fillColor,t.options.color,"none"===this.options.fillColor?null:this.options.fillColor,this.color),o["fill-opacity"]=k(t.options.fillOpacity,this.options.fillOpacity),o["stroke-width"]=k(t.options.lineWidth,this.options.lineWidth,1),t.options.opacity&&(o.opacity=t.options.opacity),o}translate(){this.chart.hasRendered&&(this.isDirtyData||!this.hasRendered)&&(this.processData(),this.generatePoints());let t=[],e=0,o=0;this.points.forEach(i=>{let r,s,n=this.chart,a=n.mapView,p=i.options,h=()=>{i.series.isDirty=!0},l=t=>{let e=n.get(t);if(e instanceof c&&e.plotX&&e.plotY)return w(e,"update",h),{x:e.plotX,y:e.plotY}},f=t=>O(t)?{lon:t[0],lat:t[1]}:t;"string"==typeof p.from?r=l(p.from):"object"==typeof p.from&&a&&(r=a.lonLatToPixels(f(p.from))),"string"==typeof p.to?s=l(p.to):"object"==typeof p.to&&a&&(s=a.lonLatToPixels(f(p.to))),i.fromPos=r,i.toPos=s,r&&s&&(e+=(r.x+s.x)/2,o+=(r.y+s.y)/2),k(i.options.weight,this.options.weight)&&t.push(k(i.options.weight,this.options.weight))}),this.smallestWeight=P(t),this.greatestWeight=x(t),this.centerOfPoints={x:e/this.points.length,y:o/this.points.length},this.points.forEach(t=>{this.getLinkWidth(t)?(t.fromPos&&(t.plotX=t.fromPos.x,t.plotY=t.fromPos.y),t.shapeType="path",t.shapeArgs=this.getPointShapeArgs(t),t.color=k(t.options.color,t.series.color)):t.shapeArgs={d:[]}})}getPointShapeArgs(t){let{fromPos:e,toPos:o}=t;if(!e||!o)return{};let i=this.getLinkWidth(t)/2,r=t.options,s=L(this.options.markerEnd,r.markerEnd),n=k(r.growTowards,this.options.growTowards),a=e.x||0,p=e.y||0,h=o.x||0,l=o.y||0,f=k(r.curveFactor,this.options.curveFactor),d=s&&s.enabled&&s.height||0;if(b(f)||(f=this.autoCurve(a,p,h,l,this.centerOfPoints.x,this.centerOfPoints.y)),d){d=A(d,4*i);let t=h-a,e=l-p,o=a+(t*=.5),r=p+(e*=.5),s=t,n=o+(t=e)*f,g=r+(e=-s)*f,[c,m]=W.normalize(n-h,g-l);c*=d,m*=d,h+=c,l+=m}let g=h-a,c=l-p,m=a+(g*=.5),u=p+(c*=.5),y=g;g=c,c=-y;let[w,x]=W.normalize(g,c),P=1+.25*Math.sqrt(f*f);w*=i*P,x*=i*P;let v=m+g*f,O=u+c*f,[E,M]=W.normalize(v-a,O-p);y=E,E=M,M=-y,E*=i,M*=i;let[C,T]=W.normalize(v-h,O-l);y=C,C=-T,T=y,C*=i,T*=i,n&&(E/=i,M/=i,w/=4,x/=4);let j={d:[["M",a-E,p-M],["Q",v-w,O-x,h-C,l-T],["L",h+C,l+T],["Q",v+w,O+x,a+E,p+M],["Z"]]};if(s&&s.enabled&&j.d){let t=W.markerEndPath([h-C,l-T],[h+C,l+T],[o.x,o.y],s);j.d.splice(2,0,...t)}let z=t.options.from,_=t.options.to,D=z.lat,S=z.lon,F=_.lat,$=_.lon;return D&&S&&(t.options.from=`${+D}, ${+S}`),F&&$&&(t.options.to=`${+F}, ${+$}`),j}}W.defaultOptions=L(y.defaultOptions,{animation:!0,dataLabels:{enabled:!1},fillOpacity:.5,markerEnd:{enabled:!0,height:"40%",width:"40%",markerType:"arrow"},width:1,maxWidth:25,minWidth:5,lineWidth:void 0,tooltip:{headerFormat:'<span style="font-size: 0.8em">{series.name}</span><br/>',pointFormat:"{point.options.from} â†’ {point.options.to}: <b>{point.options.weight}</b>"}}),v(W.prototype,{pointClass:class extends l{isValid(){let t=!(!this.options.to||!this.options.from);return[this.options.to,this.options.from].forEach(function(e){t=!!(t&&e&&(d(e)||g(f(e[0],e.lat))&&g(f(e[1],e.lon))))}),t}},pointArrayMap:["from","to","weight"],drawPoints:m.prototype.drawPoints,dataColumnKeys:m.prototype.dataColumnKeys,useMapGeometry:!0}),h().registerSeriesType("flowmap",W);let E=a();return s.default})())(r._Highcharts,r._Highcharts.SeriesRegistry)),n=e({__proto__:null,default:t(s)},[s]);export{n as f};
//# sourceMappingURL=flowmap-D_RJ_Z-d.js.map
