import{g as t}from"./index-B1MHyEgd.js";function e(t,e){return e.forEach(function(e){e&&"string"!=typeof e&&!Array.isArray(e)&&Object.keys(e).forEach(function(i){if("default"!==i&&!(i in t)){var s=Object.getOwnPropertyDescriptor(e,i);Object.defineProperty(t,i,s.get?s:{enumerable:!0,get:function(){return e[i]}})}})}),Object.freeze(t)}var i,s={exports:{}};var r,a=i?s.exports:(i=1,r="undefined"==typeof window?s.exports:window,s.exports=(t=>(()=>{let e;var i,s={944:e=>{e.exports=t}},r={};function a(t){var e=r[t];if(void 0!==e)return e.exports;var i=r[t]={exports:{}};return s[t](i,i.exports,a),i.exports}a.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return a.d(e,{a:e}),e},a.d=(t,e)=>{for(var i in e)a.o(e,i)&&!a.o(t,i)&&Object.defineProperty(t,i,{enumerable:!0,get:e[i]})},a.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e);var o={};a.d(o,{default:()=>Ct});var n=a(944),l=a.n(n);let u={cluster:{enabled:!1,allowOverlap:!0,animation:{duration:500},drillToCluster:!0,minimumClusterSize:2,layoutAlgorithm:{gridSize:50,distance:40,kmeansThreshold:100},marker:{symbol:"cluster",radius:15,lineWidth:0,lineColor:"#ffffff"},dataLabels:{enabled:!0,format:"{point.clusterPointsAmount}",verticalAlign:"middle",align:"center",style:{color:"contrast"},inside:!0}},tooltip:{clusterFormat:"<span>Clustered points: {point.clusterPointsAmount}</span><br/>"}};!function(t){t.setLength=function(t,e,i){return Array.isArray(t)?(t.length=e,t):t[i?"subarray":"slice"](0,e)},t.splice=function(t,e,i,s,r=[]){if(Array.isArray(t))return Array.isArray(r)||(r=Array.from(r)),{removed:t.splice(e,i,...r),array:t};let a=Object.getPrototypeOf(t).constructor,o=t[s?"subarray":"slice"](e,e+i),n=new a(t.length-i+r.length);return n.set(t.subarray(0,e),0),n.set(r,e),n.set(t.subarray(e+i),e+r.length),{removed:o,array:n}}}(i||(i={}));let p,{setLength:h,splice:d}=i,{fireEvent:c,objectEach:m,uniqueKey:f}=l(),g=class{constructor(t={}){this.autoId=!t.id,this.columns={},this.id=t.id||f(),this.modified=this,this.rowCount=0,this.versionTag=f();let e=0;m(t.columns||{},(t,i)=>{this.columns[i]=t.slice(),e=Math.max(e,t.length)}),this.applyRowCount(e)}applyRowCount(t){this.rowCount=t,m(this.columns,(e,i)=>{e.length!==t&&(this.columns[i]=h(e,t))})}deleteRows(t,e=1){if(e>0&&t<this.rowCount){let i=0;m(this.columns,(s,r)=>{this.columns[r]=d(s,t,e).array,i=s.length}),this.rowCount=i}c(this,"afterDeleteRows",{rowIndex:t,rowCount:e}),this.versionTag=f()}getColumn(t,e){return this.columns[t]}getColumns(t,e){return(t||Object.keys(this.columns)).reduce((t,e)=>(t[e]=this.columns[e],t),{})}getRow(t,e){return(e||Object.keys(this.columns)).map(e=>this.columns[e]?.[t])}setColumn(t,e=[],i=0,s){this.setColumns({[t]:e},i,s)}setColumns(t,e,i){let s=this.rowCount;m(t,(t,e)=>{this.columns[e]=t.slice(),s=t.length}),this.applyRowCount(s),i?.silent||(c(this,"afterSetColumns"),this.versionTag=f())}setRow(t,e=this.rowCount,i,s){let{columns:r}=this,a=i?this.rowCount+1:e+1;m(t,(t,o)=>{let n=r[o]||!1!==s?.addColumns&&Array(a);n&&(i?n=d(n,e,0,!0,[t]).array:n[e]=t,r[o]=n)}),a>this.rowCount&&this.applyRowCount(a),s?.silent||(c(this,"afterSetRows"),this.versionTag=f())}},{animObject:x}=l(),{cluster:y}=u,{addEvent:C,defined:I,error:b,isArray:k,isFunction:M,isObject:S,isNumber:A,merge:w,objectEach:P,relativeLength:X,syncTimeout:Y}=l(),O={grid:function(t,e,i,s){let r,a,o,n,l,u={},p=this.getGridOffset(),h=this.getScaledGridSize(s);for(l=0;l<t.length;l++){let s=tt(this,{x:t[l],y:e[l]});r=s.x-p.plotLeft,a=s.y-p.plotTop,o=Math.floor(r/h),u[n=Math.floor(a/h)+":"+o]??(u[n]=[]),u[n].push({dataIndex:i[l],x:t[l],y:e[l]})}return u},kmeans:function(t,e,i,s){let r,a=[],o=[],n={},l=s.processedDistance||y.layoutAlgorithm.distance,u=s.iterations,p=0,h=!0,d=0,c=0,m=[];s.processedGridSize=s.processedDistance;let f=this.markerClusterAlgorithms?this.markerClusterAlgorithms.grid.call(this,t,e,i,s):{};for(let t in f)f[t].length>1&&(r=j(f[t]),a.push({posX:r.x,posY:r.y,oldX:0,oldY:0,startPointsLen:f[t].length,points:[]}));for(;h;){for(let t of a)t.points.length=0;o.length=0;for(let s=0;s<t.length;s++)d=t[s],c=e[s],(m=this.getClusterDistancesFromPoint(a,d,c)).length&&m[0].distance<l?a[m[0].clusterIndex].points.push({x:d,y:c,dataIndex:i[s]}):o.push({x:d,y:c,dataIndex:i[s]});for(let t=0;t<a.length;t++)1===a[t].points.length&&(m=this.getClusterDistancesFromPoint(a,a[t].points[0].x,a[t].points[0].y))[1].distance<l&&(a[m[1].clusterIndex].points.push(a[t].points[0]),a[m[0].clusterIndex].points.length=0);h=!1;for(let t=0;t<a.length;t++)r=j(a[t].points),a[t].oldX=a[t].posX,a[t].oldY=a[t].posY,a[t].posX=r.x,a[t].posY=r.y,(a[t].posX>a[t].oldX+1||a[t].posX<a[t].oldX-1||a[t].posY>a[t].oldY+1||a[t].posY<a[t].oldY-1)&&(h=!0);u&&(h=p<u-1),p++}for(let t=0,e=a.length;t<e;++t)n["cluster"+t]=a[t].points;for(let t=0,e=o.length;t<e;++t)n["noise"+t]=[o[t]];return n},optimizedKmeans:function(t,e,i,s){let r,a,o,n=s.processedDistance||y.layoutAlgorithm.gridSize,l=this.getRealExtremes(),u=(this.options.cluster||{}).marker,p={};if(!this.markerClusterInfo||this.initMaxX&&this.initMaxX<l.maxX||this.initMinX&&this.initMinX>l.minX||this.initMaxY&&this.initMaxY<l.maxY||this.initMinY&&this.initMinY>l.minY)this.initMaxX=l.maxX,this.initMinX=l.minX,this.initMaxY=l.maxY,this.initMinY=l.minY,p=this.markerClusterAlgorithms?this.markerClusterAlgorithms.kmeans.call(this,t,e,i,s):{},this.baseClusters=null;else{for(let t of(this.baseClusters??(this.baseClusters={clusters:this.markerClusterInfo.clusters,noise:this.markerClusterInfo.noise}),this.baseClusters.clusters)){for(let e of(t.pointsOutside=[],t.pointsInside=[],t.data)){let i=tt(this,e),s=tt(this,t);r=Math.sqrt(Math.pow(i.x-s.x,2)+Math.pow(i.y-s.y,2)),a=n-(o=t.clusterZone?.marker?.radius?t.clusterZone.marker.radius:u?.radius?u.radius:y.marker.radius)>=0?n-o:o,r>o+a&&I(t.pointsOutside)?t.pointsOutside.push(e):I(t.pointsInside)&&t.pointsInside.push(e)}t.pointsInside.length&&(p[t.id]=t.pointsInside);let e=0;for(let i of t.pointsOutside)p[t.id+"_noise"+e++]=[i]}for(let t of this.baseClusters.noise)p[t.id]=t.data}return p}},L=[],v=0;function z(t,e,i){t.attr({opacity:e}).animate({opacity:1},i)}function D(t,e,i,s){for(let r of(T(t,s,i),e))r.point?.destroy?.()}function T(t,e,i,s,r){t.point&&(t.point.graphic&&(t.point.graphic.show(),z(t.point.graphic,e,i)),t.point.dataLabel&&(t.point.dataLabel.show(),z(t.point.dataLabel,e,i)))}function j(t){let e=t.length,i=0,s=0;for(let r=0;r<e;r++)i+=t[r].x,s+=t[r].y;return{x:i/e,y:s/e}}function E(t,e){let i=[];return i.length=e,t.clusters.forEach(function(t){t.data.forEach(function(t){i[t.dataIndex]=t})}),t.noise.forEach(function(t){i[t.data[0].dataIndex]=t.data[0]}),i}function R(){return Math.random().toString(36).substring(2,7)+"-"+v++}function V(t,e,i){t.point&&(t.point.graphic&&t.point.graphic.hide(),t.point.dataLabel&&t.point.dataLabel.hide())}function G(t){(t.point||t.target).firePointEvent("drillToCluster",t,function(t){let e=t.point||t.target,i=e.series,{xAxis:s,yAxis:r,chart:a}=i,{inverted:o,mapView:n,pointer:l}=a;if(i.options.cluster?.drillToCluster&&e.clusteredData){let t=e.clusteredData.map(t=>t.x).sort((t,e)=>t-e),i=e.clusteredData.map(t=>t.y).sort((t,e)=>t-e),u=t[0],p=t[t.length-1],h=i[0],d=i[i.length-1],c=Math.abs(.1*(p-u)),m=Math.abs(.1*(d-h)),f=Math.min(u,p)-c,g=Math.max(u,p)+c,x=Math.min(h,d)-m,y=Math.max(h,d)+m;if(n)n.fitToBounds({x1:f,x2:g,y1:x,y2:y});else if(s&&r){let t=s.toPixels(f),e=s.toPixels(g),i=r.toPixels(x),n=r.toPixels(y);o&&([t,e,i,n]=[i,n,t,e]),t>e&&([t,e]=[e,t]),i>n&&([i,n]=[n,i]),l&&(l.zoomX=!0,l.zoomY=!0),a.transform({from:{x:t,y:i,width:e-t,height:n-i}})}}})}function F(t,e){let{chart:i,xAxis:s,yAxis:r}=t;return i.mapView?i.mapView.pixelsToProjectedUnits(e):{x:s?s.toValue(e.x):0,y:r?r.toValue(e.y):0}}function _(t){let e,i,s,r=this.chart,a=r.mapView,o=x(this.options.cluster?.animation),n=o.duration||500,l=this.markerClusterInfo?.pointsState,u=l?.newState,p=l?.oldState,h=[],d=0,c=0,m=0,f=!1,g=!1;if(p&&u){let l=tt(this,i=u[t.stateId]);c=l.x-(a?0:r.plotLeft),m=l.y-(a?0:r.plotTop),1===i.parentsId.length?(e=p[u?.[t.stateId].parentsId[0]],i.point?.graphic&&e.point?.plotX&&e.point.plotY&&(e.point.plotX!==i.point.plotX||e.point.plotY!==i.point.plotY)&&(s=i.point.graphic.getBBox(),d=i.point.graphic?.isImg?0:s.width/2,i.point.graphic.attr({x:e.point.plotX-d,y:e.point.plotY-d}),i.point.graphic.animate({x:c-(i.point.graphic.radius||0),y:m-(i.point.graphic.radius||0)},o,function(){g=!0,e.point?.destroy?.()}),i.point.dataLabel?.alignAttr&&e.point.dataLabel?.alignAttr&&(i.point.dataLabel.attr({x:e.point.dataLabel.alignAttr.x,y:e.point.dataLabel.alignAttr.y}),i.point.dataLabel.animate({x:i.point.dataLabel.alignAttr.x,y:i.point.dataLabel.alignAttr.y},o)))):0===i.parentsId.length?(V(i),Y(function(){T(i,.1,o)},n/2)):(V(i),i.parentsId.forEach(function(t){p?.[t]&&(e=p[t],h.push(e),e.point?.graphic&&(f=!0,e.point.graphic.show(),e.point.graphic.animate({x:c-(e.point.graphic.radius||0),y:m-(e.point.graphic.radius||0),opacity:.4},o,function(){g=!0,D(i,h,o,.7)}),e.point.dataLabel&&-9999!==e.point.dataLabel.y&&i.point?.dataLabel?.alignAttr&&(e.point.dataLabel.show(),e.point.dataLabel.animate({x:i.point.dataLabel.alignAttr.x,y:i.point.dataLabel.alignAttr.y,opacity:.4},o))))}),Y(function(){g||D(i,h,o,.85)},n),f||Y(function(){D(i,h,o,.1)},n/2))}}function Z(){this.markerClusterSeriesData?.forEach(t=>{t?.destroy?.()}),this.markerClusterSeriesData=null}function W(){let t,e,i,s,r,a,o,n,l,u,h,d,c,m,f,x=this,{chart:b}=x,k=b.mapView,S=x.getColumn("x"),w=x.getColumn("y"),P=x.options.cluster,Y=x.getRealExtremes(),O=[],L=[],v=[];if(k&&x.is("mappoint")&&S&&w&&x.options.data?.forEach((t,e)=>{let i=x.projectPoint(t);i&&(S[e]=i.x,w[e]=i.y)}),P?.enabled&&S?.length&&w?.length&&!b.polar){h=P.layoutAlgorithm.type,(m=P.layoutAlgorithm).processedGridSize=X(m.gridSize||y.layoutAlgorithm.gridSize,b.plotWidth),m.processedDistance=X(m.distance||y.layoutAlgorithm.distance,b.plotWidth),s=m.kmeansThreshold||y.layoutAlgorithm.kmeansThreshold;let k=m.processedGridSize/2,D=F(x,{x:0,y:0}),T=F(x,{x:k,y:k});r=Math.abs(D.x-T.x),a=Math.abs(D.y-T.y);for(let t=0;t<S.length;t++)!x.dataMaxX&&(I(n)&&I(o)&&I(u)&&I(l)?A(w[t])&&A(u)&&A(l)&&(n=Math.max(S[t],n),o=Math.min(S[t],o),u=Math.max(w[t]||u,u),l=Math.min(w[t]||l,l)):(n=o=S[t],u=l=w[t])),S[t]>=Y.minX-r&&S[t]<=Y.maxX+r&&(w[t]||Y.minY)>=Y.minY-a&&(w[t]||Y.maxY)<=Y.maxY+a&&(O.push(S[t]),L.push(w[t]),v.push(t));if(I(n)&&I(o)&&A(u)&&A(l)&&(x.dataMaxX=n,x.dataMinX=o,x.dataMaxY=u,x.dataMinY=l),d=(c=(M(h)?h:x.markerClusterAlgorithms?h&&x.markerClusterAlgorithms[h]?x.markerClusterAlgorithms[h]:O.length<s?x.markerClusterAlgorithms.kmeans:x.markerClusterAlgorithms.grid:()=>!1).call(this,O,L,v,m))?x.getClusteredData(c,P):c,P.animation&&x.markerClusterInfo?.pointsState?.oldState){var z=x.markerClusterInfo.pointsState.oldState;for(let t of Object.keys(z))z[t].point?.destroy?.();t=x.markerClusterInfo.pointsState.newState}else t={};e=S.length,i=x.markerClusterInfo,d&&(x.dataTable.modified=new g({columns:{x:d.groupedXData,y:d.groupedYData}}),x.hasGroupedData=!0,x.markerClusterInfo=d,x.groupMap=d.groupMap),p.apply(this),d&&x.markerClusterInfo&&(x.markerClusterInfo.clusters?.forEach(t=>{(f=x.points[t.index]).isCluster=!0,f.clusteredData=t.data,f.clusterPointsAmount=t.data.length,t.point=f,C(f,"click",G)}),x.markerClusterInfo.noise?.forEach(t=>{t.point=x.points[t.index]}),P.animation&&x.markerClusterInfo&&(x.markerClusterInfo.pointsState={oldState:t,newState:x.getPointsState(d,i,e)}),P.animation?this.hideClusteredData():this.destroyClusteredData(),this.markerClusterSeriesData=this.hasGroupedData?this.points:null)}else p.apply(this)}function q(t,e,i){let s=[];for(let r=0;r<t.length;r++){let a=tt(this,{x:e,y:i}),o=tt(this,{x:t[r].posX,y:t[r].posY}),n=Math.sqrt(Math.pow(a.x-o.x,2)+Math.pow(a.y-o.y,2));s.push({clusterIndex:r,distance:n})}return s.sort((t,e)=>t.distance-e.distance)}function H(t,e){let i,s,r,a,o,n,l,u,p,h,d,c,m=this.options.data,f=[],g=[],x=[],C=[],I=[],A=Math.max(2,e.minimumClusterSize||2),P=0;if(M(e.layoutAlgorithm.type)&&!this.isValidGroupedDataObject(t))return b("Highcharts marker-clusters module: The custom algorithm result is not valid!",!1,this.chart),!1;for(let b in t)if(t[b].length>=A){if(r=t[b],i=R(),o=r.length,e.zones)for(let t=0;t<e.zones.length;t++)o>=e.zones[t].from&&o<=e.zones[t].to&&((d=e.zones[t]).zoneIndex=t,h=e.zones[t].marker,c=e.zones[t].className);p=j(r),"grid"!==e.layoutAlgorithm.type||e.allowOverlap?l={x:p.x,y:p.y}:(n=this.options.marker||{},l=this.preventClusterCollisions({x:p.x,y:p.y,key:b,groupedData:t,gridSize:this.getScaledGridSize(e.layoutAlgorithm),defaultRadius:n.radius||3+(n.lineWidth||0),clusterRadius:h&&h.radius?h.radius:(e.marker||{}).radius||y.marker.radius}));for(let t=0;t<o;t++)r[t].parentStateId=i;if(x.push({x:l.x,y:l.y,id:b,stateId:i,index:P,data:r,clusterZone:d,clusterZoneClassName:c}),f.push(l.x),g.push(l.y),I.push({options:{formatPrefix:"cluster",dataLabels:e.dataLabels,marker:w(e.marker,{states:e.states},h||{})}}),m?.length)for(let t=0;t<o;t++)S(m[r[t].dataIndex])&&(r[t].options=m[r[t].dataIndex]);P++,h=null}else for(let e=0;e<t[b].length;e++)s=t[b][e],i=R(),u=null,a=m?.[s.dataIndex],f.push(s.x),g.push(s.y),s.parentStateId=i,C.push({x:s.x,y:s.y,id:b,stateId:i,index:P,data:t[b]}),u=a&&"object"==typeof a&&!k(a)?w(a,{x:s.x,y:s.y}):{userOptions:a,x:s.x,y:s.y},I.push({options:u}),P++;return{clusters:x,noise:C,groupedXData:f,groupedYData:g,groupMap:I}}function N(){let{chart:t,xAxis:e,yAxis:i}=this;return{plotLeft:e&&this.dataMinX&&this.dataMaxX?e.reversed?e.toPixels(this.dataMaxX):e.toPixels(this.dataMinX):t.plotLeft,plotTop:i&&this.dataMinY&&this.dataMaxY?i.reversed?i.toPixels(this.dataMinY):i.toPixels(this.dataMaxY):t.plotTop}}function B(t,e,i){let s,r,a=e?E(e,i):[],o=E(t,i),n={};L=[],t.clusters.forEach(t=>{n[t.stateId]={x:t.x,y:t.y,id:t.stateId,point:t.point,parentsId:[]}}),t.noise.forEach(t=>{n[t.stateId]={x:t.x,y:t.y,id:t.stateId,point:t.point,parentsId:[]}});for(let t=0;t<o.length;t++)s=o[t],r=a[t],s?.parentStateId&&r?.parentStateId&&-1===n[s.parentStateId]?.parentsId.indexOf(r.parentStateId)&&(n[s.parentStateId].parentsId.push(r.parentStateId),-1===L.indexOf(r.parentStateId)&&L.push(r.parentStateId));return n}function U(){let t=this.chart,e=t.mapView?0:t.plotLeft,i=F(this,{x:e,y:t.mapView?0:t.plotTop}),s=F(this,{x:e+t.plotWidth,y:e+t.plotHeight}),r=i.x,a=s.x,o=i.y,n=s.y;return{minX:Math.min(r,a),maxX:Math.max(r,a),minY:Math.min(o,n),maxY:Math.max(o,n)}}function K(t){let e=this.xAxis,i=this.chart.mapView,s=t.processedGridSize||y.layoutAlgorithm.gridSize,r=!0,a=1,o=1;this.gridValueSize||(this.gridValueSize=i?s/i.getScale():Math.abs(e.toValue(s)-e.toValue(0)));let n=+(s/(i?this.gridValueSize*i.getScale():e.toPixels(this.gridValueSize)-e.toPixels(0))).toFixed(14);for(;r&&1!==n;){let t=Math.pow(2,a);n>.75&&n<1.25?r=!1:n>=1/t&&n<1/t*2?(r=!1,o=t):n<=t&&n>t/2&&(r=!1,o=1/t),a++}return s/o/n}function J(){let t=this.markerClusterSeriesData,e=this.markerClusterInfo?.pointsState?.oldState,i=L.map(t=>e?.[t].point?.id||"");t?.forEach(t=>{t&&-1!==i.indexOf(t.id)?(t.graphic&&t.graphic.hide(),t.dataLabel&&t.dataLabel.hide()):t?.destroy?.()})}function Q(t){let e=!1;return!!S(t)&&(P(t,t=>{if(e=!0,k(t)&&t.length){for(let i=0;i<t.length;i++)if(!S(t[i])||!t[i].x||!t[i].y)return void(e=!1)}else e=!1}),e)}function $(t){let e,i,s,r,a,o,n,l,u,p,h,d,[c,m]=t.key.split(":").map(parseFloat),f=t.gridSize,g=t.groupedData,x=t.defaultRadius,C=t.clusterRadius,b=m*f,k=c*f,M=tt(this,t),S=[],A=this.options.cluster?.marker,w=this.options.cluster?.zones,P=this.getGridOffset(),X=M.x,Y=M.y,O=0,L=0;X-=P.plotLeft,Y-=P.plotTop;for(let e=1;e<5;e++)for(n=0,s=e%2?-1:1,r=e<3?-1:1,a=Math.floor((X+s*C)/f),d=[(o=Math.floor((Y+r*C)/f))+":"+a,o+":"+m,c+":"+a];n<d.length;n++)-1===S.indexOf(d[n])&&d[n]!==t.key&&S.push(d[n]);for(let t of S)if(g[t]){g[t].posX||(p=j(g[t]),g[t].posX=p.x,g[t].posY=p.y);let s=tt(this,{x:g[t].posX||0,y:g[t].posY||0});if(e=s.x-P.plotLeft,i=s.y-P.plotTop,[u,l]=t.split(":").map(parseFloat),w){O=g[t].length;for(let t=0;t<w.length;t++)O>=w[t].from&&O<=w[t].to&&(L=I(w[t].marker?.radius)?w[t].marker.radius||0:A?.radius?A.radius:y.marker.radius)}g[t].length>1&&0===L&&A?.radius?L=A.radius:1===g[t].length&&(L=x),h=C+L,L=0,l!==m&&Math.abs(X-e)<h&&(X=l-m<0?b+C:b+f-C),u!==c&&Math.abs(Y-i)<h&&(Y=u-c<0?k+C:k+f-C)}let v=F(this,{x:X+P.plotLeft,y:Y+P.plotTop});return g[t.key].posX=v.x,g[t.key].posY=v.y,v}function tt(t,e){let{chart:i,xAxis:s,yAxis:r}=t;return i.mapView?i.mapView.projectedUnitsToPixels(e):{x:s?s.toPixels(e.x):0,y:r?r.toPixels(e.y):0}}let et=function(t,e){let i=e.prototype;!i.markerClusterAlgorithms&&(p=i.generatePoints,i.markerClusterAlgorithms=O,i.animateClusterPoint=_,i.destroyClusteredData=Z,i.generatePoints=W,i.getClusterDistancesFromPoint=q,i.getClusteredData=H,i.getGridOffset=N,i.getPointsState=B,i.getRealExtremes=U,i.getScaledGridSize=K,i.hideClusteredData=J,i.isValidGroupedDataObject=Q,i.preventClusterCollisions=$,C(e,"destroy",i.destroyClusteredData),t.plotOptions&&(t.plotOptions.series=w(t.plotOptions.series,u)))},{animObject:it}=l(),{defaultOptions:st}=l(),{composed:rt}=l(),{addEvent:at,defined:ot,error:nt,isFunction:lt,merge:ut,pushUnique:pt,syncTimeout:ht}=l();function dt(){let t=this.chart,e=0;for(let i of t.series)i.markerClusterInfo&&(e=it((i.options.cluster||{}).animation).duration||0);ht(()=>{t.tooltip&&t.tooltip.destroy()},e)}function ct(){for(let t of this.series||[])if(t.markerClusterInfo){let e=t.options.cluster,i=((t.markerClusterInfo||{}).pointsState||{}).oldState;if((e||{}).animation&&t.markerClusterInfo&&0===(t.chart.pointer?.pinchDown||[]).length&&"pan"!==((t.xAxis||{}).eventArgs||{}).trigger&&i&&Object.keys(i).length){for(let e of t.markerClusterInfo.clusters)t.animateClusterPoint(e);for(let e of t.markerClusterInfo.noise)t.animateClusterPoint(e)}}}function mt(t){let e=(((t.point||t.target).series.options.cluster||{}).events||{}).drillToCluster;lt(e)&&e.call(this,t)}function ft(){if(this.dataGroup)return nt("Highcharts marker-clusters module: Running `Point.update` when point belongs to clustered series is not supported.",!1,this.series.chart),!1}function gt(){let t=(this.options.cluster||{}).drillToCluster;if(this.markerClusterInfo&&this.markerClusterInfo.clusters)for(let e of this.markerClusterInfo.clusters)e.point&&e.point.graphic&&(e.point.graphic.addClass("highcharts-cluster-point"),t&&e.point&&(e.point.graphic.css({cursor:"pointer"}),e.point.dataLabel&&e.point.dataLabel.css({cursor:"pointer"})),ot(e.clusterZone)&&e.point.graphic.addClass(e.clusterZoneClassName||"highcharts-cluster-zone-"+e.clusterZone.zoneIndex))}function xt(t,i,s,r){let a=s/2,o=r/2,n=e.arc(t+a,i+o,a-4,o-4,{start:.5*Math.PI,end:2.5*Math.PI,open:!1}),l=e.arc(t+a,i+o,a-3,o-3,{start:.5*Math.PI,end:2.5*Math.PI,innerR:a-2,open:!1});return e.arc(t+a,i+o,a-1,o-1,{start:.5*Math.PI,end:2.5*Math.PI,innerR:a,open:!1}).concat(l,n)}(st.plotOptions||{}).series=ut((st.plotOptions||{}).series,u);let yt=l();(function(t,e,i,s){if(pt(rt,"MarkerClusters")){let r=s.prototype.pointClass,{scatter:a}=s.types;at(t,"setExtremes",dt),at(e,"render",ct),at(r,"drillToCluster",mt),at(r,"update",ft),at(s,"afterRender",gt),a&&et(i,a)}})(yt.Axis,yt.Chart,yt.defaultOptions,yt.Series),function(t){(e=t.prototype.symbols).cluster=xt}(yt.SVGRenderer);let Ct=l();return o.default})())(r._Highcharts)),o=e({__proto__:null,default:t(a)},[a]);export{o as m};
//# sourceMappingURL=marker-clusters-C776-7iz.js.map
